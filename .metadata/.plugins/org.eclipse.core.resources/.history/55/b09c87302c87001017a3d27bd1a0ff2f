/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "usb_device.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "usbd_custom_hid_if.h"
#include <string.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef htim2;

/* USER CODE BEGIN PV */
uint8_t tx_buffer[64];
static uint8_t rx_buffer[64];
static uint16_t rx_len;
static uint32_t last_send_time = 0;

// 74HC165 Pin Definitions
#define PIN_PL_PORT    GPIOB
#define PIN_PL_PIN     GPIO_PIN_1     // SH/LD (PL) - active LOW latch
#define PIN_CLK_PORT   GPIOB
#define PIN_CLK_PIN    GPIO_PIN_0     // CP (Clock)
#define PIN_DATA_PORT  GPIOA
#define PIN_DATA_PIN   GPIO_PIN_10    // Q7 first chip
#define PIN_CE_PORT    GPIOB
#define PIN_CE_PIN     GPIO_PIN_3     // CE - active HIGH inhibit

#define BUZZER_PORT    GPIOA
#define BUZZER_PIN     GPIO_PIN_0

// Button Mode Enumeration
typedef enum { PRESS_RELEASE, TOGGLE } ButtonMode;

// Button Information Structure
typedef struct {
    const char* baseCmd;
    ButtonMode mode;
    uint8_t lastPhysicalState;
    uint8_t toggleState;
} BtnInfo;

// Combo Information Structure
typedef struct {
    const char* states[4];
    ButtonMode mode;
    uint8_t lastState;
    uint8_t toggleStates[4];
} ComboInfo;

// Button Array (13 regular buttons)
BtnInfo buttonMap[13] = {
    {"A1", PRESS_RELEASE, 0, 0}, {"A2", PRESS_RELEASE, 0, 0},
    {"A3", PRESS_RELEASE, 0, 0}, {"A4", PRESS_RELEASE, 0, 0},
    {"1", TOGGLE, 0, 0}, {"2", PRESS_RELEASE, 0, 0},
    {"3", PRESS_RELEASE, 0, 0}, {"4", PRESS_RELEASE, 0, 0},
    {"5", PRESS_RELEASE, 0, 0}, {"6", PRESS_RELEASE, 0, 0},
    {"7", PRESS_RELEASE, 0, 0}, {"8", PRESS_RELEASE, 0, 0},
    {"9", PRESS_RELEASE, 0, 0}
};

// Combo Button Configuration
ComboInfo combo = {
    {"B1", "B2", "B3", "B4"},
    PRESS_RELEASE,
    0xFF,
    {0, 0, 0, 0}
};

// Timing Variables
uint32_t beepStartTime = 0;
uint32_t beepDuration = 0;
uint8_t beeping = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_TIM2_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
// Bit reversal function
uint8_t reverseBits(uint8_t b) {
    b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    return b;
}

// Latch inputs from 74HC165
static inline void latchInputs(void) {
    HAL_GPIO_WritePin(PIN_CE_PORT, PIN_CE_PIN, GPIO_PIN_SET);    // inhibit
    HAL_GPIO_WritePin(PIN_PL_PORT, PIN_PL_PIN, GPIO_PIN_RESET);  // latch
    HAL_Delay(1);  // Using HAL_Delay instead of delayMicroseconds
    HAL_GPIO_WritePin(PIN_PL_PORT, PIN_PL_PIN, GPIO_PIN_SET);
    HAL_Delay(1);
}

// Read 8 bits from 74HC165 (LSB first)
uint8_t read165_LSBFIRST_phase(void) {
    uint8_t value = 0;
    for (int i = 0; i < 8; i++) {
        HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_RESET);
        HAL_Delay(1);

        if (HAL_GPIO_ReadPin(PIN_DATA_PORT, PIN_DATA_PIN) == GPIO_PIN_SET) {
            value |= (1 << i);
        }

        HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_SET);
        HAL_Delay(1);
    }
    return value;
}

// Send command via USB HID
void sendCmd(const char* cmd) {
    // Clear buffer
    memset(tx_buffer, 0, sizeof(tx_buffer));

    // Copy command (first 3 characters: "0x" + command)
    tx_buffer[0] = '0';
    tx_buffer[1] = 'x';
    strncpy((char*)&tx_buffer[2], cmd, 62); // Leave space for null terminator

    // Send via USB HID
    USBD_CUSTOM_HID_SendReport(&hUsbDeviceFS, tx_buffer, 64);
}

void startTone(uint32_t frequency, uint32_t duration) {
    if (frequency == 0) {
        // Stop PWM on TIM2_CH1
        HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);
        return;
    }

    // Assuming 48 MHz system clock
    uint32_t timer_clk = 48000000;
    // Compute prescaler for given frequency (ARR = 1000)
    uint32_t presc = (timer_clk / (1000U * frequency)) - 1U;

    // Update TIM2 prescaler and period
    __HAL_TIM_SET_PRESCALER(&htim2, presc);
    __HAL_TIM_SET_AUTORELOAD(&htim2, 1000U - 1U);
    // 50% duty cycle
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 500U);

    // Start PWM on PA0 (TIM2_CH1)
    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);

    // Schedule stop
    beepStartTime = HAL_GetTick();
    beepDuration  = duration;
    beeping       = 1;
}

void stopTone(void) {
    HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);
    beeping = 0;
}

// Wrapper for 4 kHz beep
void startBeep(uint32_t duration) {
    startTone(4000U, duration);
}

void handleBeep(void) {
    if (beeping && ((HAL_GetTick() - beepStartTime) >= beepDuration)) {
        stopTone();
    }
}

// Process individual button
void processButton(int idx, uint8_t pressedNow) {
    BtnInfo *btn = &buttonMap[idx];

    if (btn->mode == PRESS_RELEASE) {
        if (pressedNow != btn->lastPhysicalState) {
            char cmd[8];
            snprintf(cmd, sizeof(cmd), "%s%d", btn->baseCmd, pressedNow ? 1 : 0);
            sendCmd(cmd);
            btn->lastPhysicalState = pressedNow;
        }
    } else { // TOGGLE mode
        if (!btn->lastPhysicalState && pressedNow) {
            btn->toggleState = !btn->toggleState;
            char cmd[8];
            snprintf(cmd, sizeof(cmd), "%s%d", btn->baseCmd, btn->toggleState ? 1 : 0);
            sendCmd(cmd);
            startBeep(100);  // Beep for 100ms on toggle
        }
        btn->lastPhysicalState = pressedNow;
    }
}

// Process combo buttons
void processCombo(uint8_t state) {
    if (combo.mode == PRESS_RELEASE) {
        if (state != combo.lastState) {
            // Release previous state
            if (combo.lastState != 0xFF) {
                char cmd[8];
                snprintf(cmd, sizeof(cmd), "%s0", combo.states[combo.lastState]);
                sendCmd(cmd);
            }
            // Press new state
            if (state != 0xFF) {
                char cmd[8];
                snprintf(cmd, sizeof(cmd), "%s1", combo.states[state]);
                sendCmd(cmd);
            }
            combo.lastState = state;
        }
    } else { // TOGGLE mode
        if (state != combo.lastState && state != 0xFF) {
            combo.toggleStates[state] = !combo.toggleStates[state];
            char cmd[8];
            snprintf(cmd, sizeof(cmd), "%s%d", combo.states[state], combo.toggleStates[state] ? 1 : 0);
            sendCmd(cmd);
            combo.lastState = state;
        }
    }
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_TIM2_Init();
  MX_USB_DEVICE_Init();
  /* USER CODE BEGIN 2 */
  uint8_t init_msg[] = "STM32 HID Device Ready";
   HAL_Delay(1000);
   HID_SendData(init_msg, strlen((char*)init_msg));
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  if (HID_IsDataReceived())
	      {
	        if (HID_ReceiveData(rx_buffer, &rx_len))
	        {
	          if (rx_buffer[0] == 0x01)
	          {
	            uint8_t response[] = "Received command 0x01";
	            HID_SendData(response, strlen((char*)response));
	          }
	          else if (rx_buffer[0] == 0x02)
	          {
	            uint8_t response[] = "Received command 0x02";
	            HID_SendData(response, strlen((char*)response));
	          }
	          else
	          {
	            uint8_t response[32];
	            snprintf((char*)response, sizeof(response), "Unknown cmd: 0x%02X", rx_buffer[0]);
	            HID_SendData(response, strlen((char*)response));
	          }
	        }
	      }

	      if (HAL_GetTick() - last_send_time > 5000)
	      {
	        uint8_t heartbeat[] = "Heartbeat";
	        HID_SendData(heartbeat, strlen((char*)heartbeat));
	        last_send_time = HAL_GetTick();
	      }

	      HAL_Delay(10);
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
  {
    Error_Handler();
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 4294967295;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_3, GPIO_PIN_RESET);

  /*Configure GPIO pins : PB0 PB1 PB3 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_3;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : PA10 */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
