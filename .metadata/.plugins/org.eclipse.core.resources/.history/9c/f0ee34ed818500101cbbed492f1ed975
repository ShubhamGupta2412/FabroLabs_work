/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "usb_device.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
// USB HID Buffers
uint8_t tx_buffer[64];
uint8_t report_buffer[64];
uint8_t flag_tx = 0;
uint8_t flag_rx = 0;
extern USBD_HandleTypeDef hUsbDeviceFS;

// 74HC165 Pin Definitions
#define PIN_PL_PORT    GPIOB
#define PIN_PL_PIN     GPIO_PIN_1     // SH/LD (PL) - active LOW latch
#define PIN_CLK_PORT   GPIOB
#define PIN_CLK_PIN    GPIO_PIN_0     // CP (Clock)
#define PIN_DATA_PORT  GPIOA
#define PIN_DATA_PIN   GPIO_PIN_10    // Q7 first chip
#define PIN_CE_PORT    GPIOB
#define PIN_CE_PIN     GPIO_PIN_3     // CE - active HIGH inhibit

#define BUZZER_PORT    GPIOA
#define BUZZER_PIN     GPIO_PIN_8

// Button Mode Enumeration
typedef enum { PRESS_RELEASE, TOGGLE } ButtonMode;

// Button Information Structure
typedef struct {
    const char* baseCmd;
    ButtonMode mode;
    uint8_t lastPhysicalState;
    uint8_t toggleState;
} BtnInfo;

// Combo Information Structure
typedef struct {
    const char* states[4];
    ButtonMode mode;
    uint8_t lastState;
    uint8_t toggleStates[4];
} ComboInfo;

// Button Array (13 regular buttons)
BtnInfo buttonMap[13] = {
    {"A1", PRESS_RELEASE, 0, 0}, {"A2", PRESS_RELEASE, 0, 0},
    {"A3", PRESS_RELEASE, 0, 0}, {"A4", PRESS_RELEASE, 0, 0},
    {"1", PRESS_RELEASE, 0, 0}, {"2", PRESS_RELEASE, 0, 0},
    {"3", PRESS_RELEASE, 0, 0}, {"4", PRESS_RELEASE, 0, 0},
    {"5", PRESS_RELEASE, 0, 0}, {"6", PRESS_RELEASE, 0, 0},
    {"7", PRESS_RELEASE, 0, 0}, {"8", PRESS_RELEASE, 0, 0},
    {"9", PRESS_RELEASE, 0, 0}
};

// Combo Button Configuration
ComboInfo combo = {
    {"B1", "B2", "B3", "B4"},
    PRESS_RELEASE,
    0xFF,
    {0, 0, 0, 0}
};

// Timing Variables
uint32_t beepStartTime = 0;
uint32_t beepDuration = 0;
uint8_t beeping = 0;
/* USER CODE END PV */


/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
// Bit reversal function
uint8_t reverseBits(uint8_t b) {
    b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    return b;
}

// Latch inputs from 74HC165
static inline void latchInputs(void) {
    HAL_GPIO_WritePin(PIN_CE_PORT, PIN_CE_PIN, GPIO_PIN_SET);    // inhibit
    HAL_GPIO_WritePin(PIN_PL_PORT, PIN_PL_PIN, GPIO_PIN_RESET);  // latch
    HAL_Delay(1);  // Using HAL_Delay instead of delayMicroseconds
    HAL_GPIO_WritePin(PIN_PL_PORT, PIN_PL_PIN, GPIO_PIN_SET);
    HAL_Delay(1);
}

// Read 8 bits from 74HC165 (LSB first)
uint8_t read165_LSBFIRST_phase(void) {
    uint8_t value = 0;
    for (int i = 0; i < 8; i++) {
        HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_RESET);
        HAL_Delay(1);

        if (HAL_GPIO_ReadPin(PIN_DATA_PORT, PIN_DATA_PIN) == GPIO_PIN_SET) {
            value |= (1 << i);
        }

        HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_SET);
        HAL_Delay(1);
    }
    return value;
}

// Send command via USB HID
void sendCmd(const char* cmd) {
    // Clear buffer
    memset(tx_buffer, 0, sizeof(tx_buffer));

    // Copy command (first 3 characters: "0x" + command)
    tx_buffer[0] = '0';
    tx_buffer[1] = 'x';
    strncpy((char*)&tx_buffer[2], cmd, 62); // Leave space for null terminator

    // Send via USB HID
    USBD_CUSTOM_HID_SendReport(&hUsbDeviceFS, tx_buffer, 64);
}

// Buzzer Control Functions
void startBeep(uint32_t duration) {
    HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_SET);
    beepStartTime = HAL_GetTick();
    beepDuration = duration;
    beeping = 1;
}

void handleBeep(void) {
    if (beeping && (HAL_GetTick() - beepStartTime >= beepDuration)) {
        HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_RESET);
        beeping = 0;
    }
}

// Process individual button
void processButton(int idx, uint8_t pressedNow) {
    BtnInfo *btn = &buttonMap[idx];

    if (btn->mode == PRESS_RELEASE) {
        if (pressedNow != btn->lastPhysicalState) {
            char cmd[8];
            snprintf(cmd, sizeof(cmd), "%s%d", btn->baseCmd, pressedNow ? 1 : 0);
            sendCmd(cmd);
            btn->lastPhysicalState = pressedNow;
        }
    } else { // TOGGLE mode
        if (!btn->lastPhysicalState && pressedNow) {
            btn->toggleState = !btn->toggleState;
            char cmd[8];
            snprintf(cmd, sizeof(cmd), "%s%d", btn->baseCmd, btn->toggleState ? 1 : 0);
            sendCmd(cmd);
            startBeep(100);  // Beep for 100ms on toggle
        }
        btn->lastPhysicalState = pressedNow;
    }
}

// Process combo buttons
void processCombo(uint8_t state) {
    if (combo.mode == PRESS_RELEASE) {
        if (state != combo.lastState) {
            // Release previous state
            if (combo.lastState != 0xFF) {
                char cmd[8];
                snprintf(cmd, sizeof(cmd), "%s0", combo.states[combo.lastState]);
                sendCmd(cmd);
            }
            // Press new state
            if (state != 0xFF) {
                char cmd[8];
                snprintf(cmd, sizeof(cmd), "%s1", combo.states[state]);
                sendCmd(cmd);
            }
            combo.lastState = state;
        }
    } else { // TOGGLE mode
        if (state != combo.lastState && state != 0xFF) {
            combo.toggleStates[state] = !combo.toggleStates[state];
            char cmd[8];
            snprintf(cmd, sizeof(cmd), "%s%d", combo.states[state], combo.toggleStates[state] ? 1 : 0);
            sendCmd(cmd);
            combo.lastState = state;
        }
    }
}
/* USER CODE END 0 */


/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USB_DEVICE_Init();
  /* USER CODE BEGIN 2 */
  // Initialize tx_buffer with test pattern
  for (uint8_t i = 0; i < 64; i++) {
      tx_buffer[i] = i;
  }

  // Initialize GPIO pins
  HAL_GPIO_WritePin(PIN_PL_PORT, PIN_PL_PIN, GPIO_PIN_SET);
  HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(PIN_CE_PORT, PIN_CE_PIN, GPIO_PIN_SET);
  /* USER CODE END 2 */


  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  /* USER CODE BEGIN 3 */
	  // Handle incoming USB data
	  if (flag_rx == 1) {
	      // Check first byte for LED control commands
	      if (report_buffer[0] == 1) {
	          // Turn on onboard LED (if available)
	          // HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_SET);
	      } else if (report_buffer[0] == 2) {
	          // Turn off onboard LED
	          // HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_RESET);
	      }
	      flag_rx = 0;
	  }

	  // Read button matrix via 74HC165
	  latchInputs();
	  HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_SET);
	  HAL_GPIO_WritePin(PIN_CE_PORT, PIN_CE_PIN, GPIO_PIN_RESET);

	  uint8_t byteU1 = reverseBits(read165_LSBFIRST_phase()) & 0x7F;
	  uint8_t byteU2 = reverseBits(read165_LSBFIRST_phase());

	  HAL_GPIO_WritePin(PIN_CE_PORT, PIN_CE_PIN, GPIO_PIN_SET);
	  HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_RESET);

	  int idx = 0;

	  // Process Knobs (U2 0..3)
	  for (int i = 0; i < 4; i++, idx++) {
	      uint8_t pressedNow = (byteU2 >> i) & 1;
	      processButton(idx, pressedNow);
	  }

	  // Process Normal buttons (U2 4..7, U1 0..4)
	  for (int i = 4; i < 8; i++, idx++) {
	      uint8_t pressedNow = (byteU2 >> i) & 1;
	      processButton(idx, pressedNow);
	  }

	  for (int i = 0; i < 5; i++, idx++) {
	      uint8_t pressedNow = (byteU1 >> i) & 1;
	      processButton(idx, pressedNow);
	  }

	  // Process combo state
	  uint8_t comboState = ((byteU1 >> 6) & 1) << 1 | ((byteU1 >> 5) & 1);
	  processCombo(comboState);

	  // Handle buzzer
	  handleBeep();

	  HAL_Delay(50);  // 50ms delay between reads

  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
  {
    Error_Handler();
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_3, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);

  /*Configure GPIO pins : PB0 PB1 PB3 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_3;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : PA8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : PA10 */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
