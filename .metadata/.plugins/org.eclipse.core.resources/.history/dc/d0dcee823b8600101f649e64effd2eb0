/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "usb_device.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef htim2;

/* USER CODE BEGIN PV */
// USB HID Buffers
uint8_t tx_buffer[64];
uint8_t report_buffer[64];
uint8_t flag_tx = 0;
uint8_t flag_rx = 0;
extern USBD_HandleTypeDef hUsbDeviceFS;

// 74HC165 Pin Definitions
#define PIN_PL_PORT    GPIOB
#define PIN_PL_PIN     GPIO_PIN_1     // SH/LD (PL) - active LOW latch
#define PIN_CLK_PORT   GPIOB
#define PIN_CLK_PIN    GPIO_PIN_0     // CP (Clock)
#define PIN_DATA_PORT  GPIOA
#define PIN_DATA_PIN   GPIO_PIN_10    // Q7 first chip
#define PIN_CE_PORT    GPIOB
#define PIN_CE_PIN     GPIO_PIN_3     // CE - active HIGH inhibit

#define BUZZER_PORT    GPIOA
#define BUZZER_PIN     GPIO_PIN_0

// Button Mode Enumeration
typedef enum { PRESS_RELEASE, TOGGLE } ButtonMode;

// Button Information Structure
typedef struct {
    const char* baseCmd;
    ButtonMode mode;
    uint8_t lastPhysicalState;
    uint8_t toggleState;
} BtnInfo;

// Combo Information Structure
typedef struct {
    const char* states[4];
    ButtonMode mode;
    uint8_t lastState;
    uint8_t toggleStates[4];
} ComboInfo;

// Button Array (13 regular buttons)
BtnInfo buttonMap[13] = {
    {"A1", PRESS_RELEASE, 0, 0}, {"A2", PRESS_RELEASE, 0, 0},
    {"A3", PRESS_RELEASE, 0, 0}, {"A4", PRESS_RELEASE, 0, 0},
    {"1", TOGGLE, 0, 0}, {"2", PRESS_RELEASE, 0, 0},
    {"3", PRESS_RELEASE, 0, 0}, {"4", PRESS_RELEASE, 0, 0},
    {"5", PRESS_RELEASE, 0, 0}, {"6", PRESS_RELEASE, 0, 0},
    {"7", PRESS_RELEASE, 0, 0}, {"8", PRESS_RELEASE, 0, 0},
    {"9", PRESS_RELEASE, 0, 0}
};

// Combo Button Configuration
ComboInfo combo = {
    {"B1", "B2", "B3", "B4"},
    PRESS_RELEASE,
    0xFF,
    {0, 0, 0, 0}
};

// Timing Variables
uint32_t beepStartTime = 0;
uint32_t beepDuration = 0;
uint8_t beeping = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_TIM2_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
// Bit reversal function
uint8_t reverseBits(uint8_t b) {
    b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    return b;
}

// Latch inputs from 74HC165
static inline void latchInputs(void) {
    HAL_GPIO_WritePin(PIN_CE_PORT, PIN_CE_PIN, GPIO_PIN_SET);    // inhibit
    HAL_GPIO_WritePin(PIN_PL_PORT, PIN_PL_PIN, GPIO_PIN_RESET);  // latch
    HAL_Delay(1);  // Using HAL_Delay instead of delayMicroseconds
    HAL_GPIO_WritePin(PIN_PL_PORT, PIN_PL_PIN, GPIO_PIN_SET);
    HAL_Delay(1);
}

// Read 8 bits from 74HC165 (LSB first)
uint8_t read165_LSBFIRST_phase(void) {
    uint8_t value = 0;
    for (int i = 0; i < 8; i++) {
        HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_RESET);
        HAL_Delay(1);

        if (HAL_GPIO_ReadPin(PIN_DATA_PORT, PIN_DATA_PIN) == GPIO_PIN_SET) {
            value |= (1 << i);
        }

        HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_SET);
        HAL_Delay(1);
    }
    return value;
}

// Send command via USB HID
void sendCmd(const char* cmd) {
    // Clear buffer
    memset(tx_buffer, 0, sizeof(tx_buffer));

    // Copy command (first 3 characters: "0x" + command)
    tx_buffer[0] = '0';
    tx_buffer[1] = 'x';
    strncpy((char*)&tx_buffer[2], cmd, 62); // Leave space for null terminator

    // Send via USB HID
    USBD_CUSTOM_HID_SendReport(&hUsbDeviceFS, tx_buffer, 64);
}

void startTone(uint32_t frequency, uint32_t duration) {
    if (frequency == 0) {
        // Stop PWM on TIM2_CH1
        HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);
        return;
    }

    // Assuming 48 MHz system clock
    uint32_t timer_clk = 48000000;
    // Compute prescaler for given frequency (ARR = 1000)
    uint32_t presc = (timer_clk / (1000U * frequency)) - 1U;

    // Update TIM2 prescaler and period
    __HAL_TIM_SET_PRESCALER(&htim2, presc);
    __HAL_TIM_SET_AUTORELOAD(&htim2, 1000U - 1U);
    // 50% duty cycle
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 500U);

    // Start PWM on PA0 (TIM2_CH1)
    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);

    // Schedule stop
    beepStartTime = HAL_GetTick();
    beepDuration  = duration;
    beeping       = 1;
}

void stopTone(void) {
    HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);
    beeping = 0;
}

// Wrapper for 4 kHz beep
void startBeep(uint32_t duration) {
    startTone(4000U, duration);
}

void handleBeep(void) {
    if (beeping && ((HAL_GetTick() - beepStartTime) >= beepDuration)) {
        stopTone();
    }
}

// Process individual button
void processButton(int idx, uint8_t pressedNow) {
    BtnInfo *btn = &buttonMap[idx];

    if (btn->mode == PRESS_RELEASE) {
        if (pressedNow != btn->lastPhysicalState) {
            char cmd[8];
            snprintf(cmd, sizeof(cmd), "%s%d", btn->baseCmd, pressedNow ? 1 : 0);
            sendCmd(cmd);
            btn->lastPhysicalState = pressedNow;
        }
    } else { // TOGGLE mode
        if (!btn->lastPhysicalState && pressedNow) {
            btn->toggleState = !btn->toggleState;
            char cmd[8];
            snprintf(cmd, sizeof(cmd), "%s%d", btn->baseCmd, btn->toggleState ? 1 : 0);
            sendCmd(cmd);
            startBeep(100);  // Beep for 100ms on toggle
        }
        btn->lastPhysicalState = pressedNow;
    }
}

// Process combo buttons
void processCombo(uint8_t state) {
    if (combo.mode == PRESS_RELEASE) {
        if (state != combo.lastState) {
            // Release previous state
            if (combo.lastState != 0xFF) {
                char cmd[8];
                snprintf(cmd, sizeof(cmd), "%s0", combo.states[combo.lastState]);
                sendCmd(cmd);
            }
            // Press new state
            if (state != 0xFF) {
                char cmd[8];
                snprintf(cmd, sizeof(cmd), "%s1", combo.states[state]);
                sendCmd(cmd);
            }
            combo.lastState = state;
        }
    } else { // TOGGLE mode
        if (state != combo.lastState && state != 0xFF) {
            combo.toggleStates[state] = !combo.toggleStates[state];
            char cmd[8];
            snprintf(cmd, sizeof(cmd), "%s%d", combo.states[state], combo.toggleStates[state] ? 1 : 0);
            sendCmd(cmd);
            combo.lastState = state;
        }
    }
}

// Button name to index mapping
int getButtonIndex(const char* buttonName) {
    for (int i = 0; i < 13; i++) {
        if (strcmp(buttonName, buttonMap[i].baseCmd) == 0) {
            return i;
        }
    }
    return -1;  // Not found
}

// Process incoming USB commands
void processIncomingCommand(void) {
    char command[64];
    char buttonName[8];
    int mode;

    // Convert received bytes to string (assuming ASCII commands)
    memcpy(command, report_buffer, 64);
    command[63] = '\0';  // Ensure null termination

    // Parse command format: "SETMODE A1 1" or "A1 0"
    if (sscanf(command, "SETMODE %7s %d", buttonName, &mode) == 2) {
        int btnIndex = getButtonIndex(buttonName);

        if (btnIndex >= 0 && btnIndex < 13 && (mode == 0 || mode == 1)) {
            // Update button mode
            buttonMap[btnIndex].mode = (mode == 0) ? PRESS_RELEASE : TOGGLE;

            // Send confirmation back to PC
            char response[64];
            snprintf(response, sizeof(response), "OK_%s_%s",
                     buttonName, (mode == 0) ? "PRESS_RELEASE" : "TOGGLE");
            sendCmd(response);

            // Optional: Beep confirmation
            startBeep(150);
        }
        else {
            sendCmd("ERROR_INVALID_BUTTON_OR_MODE");
        }
    }
    else if (sscanf(command, "%7s %d", buttonName, &mode) == 2) {
        // Simple format: "A1 1"
        int btnIndex = getButtonIndex(buttonName);

        if (btnIndex >= 0 && btnIndex < 13 && (mode == 0 || mode == 1)) {
            buttonMap[btnIndex].mode = (mode == 0) ? PRESS_RELEASE : TOGGLE;

            char response[64];
            snprintf(response, sizeof(response), "%s_%s",
                     buttonName, (mode == 0) ? "PR" : "TG");
            sendCmd(response);

            startBeep(100);
        }
    }
    else if (strncmp(command, "STATUS", 6) == 0) {
        // Status query command
        char status[64];
        snprintf(status, sizeof(status), "MODES_A1_%d_1_%d_5_%d",
                 buttonMap[0].mode, buttonMap[4].mode, buttonMap[8].mode);
        sendCmd(status);
    }
    else if (strncmp(command, "BEEP", 4) == 0) {
        int duration = 200;
        sscanf(command, "BEEP %d", &duration);
        startBeep(duration);
        sendCmd("BEEPED");
    }

    flag_rx = 0;  // Clear flag after processing
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_TIM2_Init();
  MX_USB_DEVICE_Init();
  /* USER CODE BEGIN 2 */
  // Initialize tx_buffer with test pattern
  for (uint8_t i = 0; i < 64; i++) {
      tx_buffer[i] = i;
  }

  // Initialize GPIO pins
  HAL_GPIO_WritePin(PIN_PL_PORT, PIN_PL_PIN, GPIO_PIN_SET);
  HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(PIN_CE_PORT, PIN_CE_PIN, GPIO_PIN_SET);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  // Handle incoming USB data
	  /*if (flag_rx == 1) {
	      processIncomingCommand();  // Process PC commands
	  }
	  */

	  if (flag_rx == 1)
	  {
	  //Check if the first byte of the report buffer equals 1
	  if (report_buffer[0] == 1)
	  {
	//Turn the user LED on
	HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, SET);
	  }

	  //Check if the first byte of the report buffer equals 2
	  else if (report_buffer[0] == 2)
	  {
	//Turn the user LED off
	HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, RESET);
	  }

	  flag_rx = 0;
	  }

	  // Read button matrix via 74HC165
	  latchInputs();
	  HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_SET);
	  HAL_GPIO_WritePin(PIN_CE_PORT, PIN_CE_PIN, GPIO_PIN_RESET);

	  uint8_t byteU1 = reverseBits(read165_LSBFIRST_phase()) & 0x7F;
	  uint8_t byteU2 = reverseBits(read165_LSBFIRST_phase());

	  HAL_GPIO_WritePin(PIN_CE_PORT, PIN_CE_PIN, GPIO_PIN_SET);
	  HAL_GPIO_WritePin(PIN_CLK_PORT, PIN_CLK_PIN, GPIO_PIN_RESET);

	  int idx = 0;

	  // Process Knobs (U2 0..3)
	  for (int i = 0; i < 4; i++, idx++) {
	      uint8_t pressedNow = (byteU2 >> i) & 1;
	      processButton(idx, pressedNow);
	  }

	  // Process Normal buttons (U2 4..7, U1 0..4)
	  for (int i = 4; i < 8; i++, idx++) {
	      uint8_t pressedNow = (byteU2 >> i) & 1;
	      processButton(idx, pressedNow);
	  }

	  for (int i = 0; i < 5; i++, idx++) {
	      uint8_t pressedNow = (byteU1 >> i) & 1;
	      processButton(idx, pressedNow);
	  }

	  // Process combo state
	  uint8_t comboState = ((byteU1 >> 6) & 1) << 1 | ((byteU1 >> 5) & 1);
	  processCombo(comboState);

	  // Handle buzzer
	  handleBeep();

	  HAL_Delay(50);  // 50ms delay between reads
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
  {
    Error_Handler();
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 4294967295;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_3, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);

  /*Configure GPIO pins : PB0 PB1 PB3 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_3;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : PA8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : PA10 */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
